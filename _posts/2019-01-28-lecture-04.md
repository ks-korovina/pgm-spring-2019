---
layout: distill
title: "Lecture 4: Exact inference"
description: Introducing the problem of inference and finding exact solutions to it in graphical models
date: 2019-01-28

lecturers:
  - name: Eric Xing
    url: "https://www.cs.cmu.edu/~epxing/"

authors:
  - name: Tingfung Lau  # author's full name; let's order by sections
    url: "#"  # optional URL to the author's homepage
  - name: Austin Dill
    url: "#"
  - name: Lingxiao Zhao
    url: "#"
  - name: Ksenia Korovina
    url: "#"

editors:
  - name: Xun Zheng  # editor's full name
    url: "#"  # optional URL to the editor's homepage

abstract: >
  An example abstract block.
---

## Introduction

## Elimination Algorithm and Examples

Now that we understand the problem of inference, we will examine some simple cases to build intuition for a general method for exact inference.

### Elimination on Chains

Consider a simple chain on variables $A, B, C, D, E$ as seen below. 

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-04/chain1.png' | relative_url }}" />
    </div>
  </div>
  <figcaption>
    <strong>Chain PGM.</strong>
  </figcaption>
</figure>

Imagine we want the probability of $E=e$ regardless of the values of $A, B, C, D$. Naively, we could sum over the joint probability:

$$
P(e) = \sum_d \sum_c \sum_b \sum_a P(a, b, c, d, e)
$$

This will require an exponential number of terms. Thankfully, we can use the properties of Bayesian Networks to cut down on this computational cost. Since Bayesian Networks encode conditional independences, we can decompose the joint probability as follows:

$$
P(e) = \sum_d \sum_c \sum_b \sum_a P(a) P (b | a) P(c | b) P(d | c) P(e | d)
$$

This decomposition has allowed us to decouple conditionally independent variables and we can therefore push in and isolate summations, like the following:

$$
P(e) = \sum_d \sum_c \sum_b P(c | b) P(d | c) P(e | d) \sum_a P(a) P (b | a)
$$

Focusing on the final term, $\sum_a P(a)P(b\vert a)$, we see that this marginalizes over $a$ and leaves us with a function of only $b$. We will generally refer to this as $\phi(b)$ but semantically it is equivalent to $P(b)$. We are left with the following expression for the marginal probability of $e$. 

$$
P(e) = \sum_d \sum_c \sum_b P(c | b) P(d | c) P(e | d) P(b)
$$

Note that because the variable $a$ is no longer part of this expression we will say $a$ has been *eliminated*. We are therefore left with a new graphical model for our situation:

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-04/chain2.png' | relative_url }}" />
    </div>
  </div>
  <figcaption>
    <strong>Graphical Model after Elimination of A.</strong>
  </figcaption>
</figure>

Repeating this, we get the following sequence of steps:


<d-math block>
\begin{aligned}
P(e) &= \sum_d \sum_c P(d | c) P(e | d) \sum_b P(c | b) P(b) \\
&= \sum_d \sum_c P(d | c) P(e | d) P(c) \\
&= \sum_d P(e | d) \sum_c P(d | c) P(c) \\
&= \sum_d P(e | d) P(d) \\
\end{aligned}
</d-math>


As each elimination step costs $O(Val\vert X_i \vert \times \vert X_{i+1} \vert)$, the overall complexity is $O(nk^2)$, a huge improvement overall from the exponential runtime of the naive summation of the joint probability. 

### Elimination in Hidden Markov Models

Now we will consider a model frequently used in time-series analysis and Natural Language Processing known as a Hidden Markov Model. 

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-04/HMM.png' | relative_url }}" />
    </div>
  </div>
  <figcaption>
    <strong>Hidden Markov Model.</strong>
  </figcaption>
</figure>

Naively we could find the conditional probability of $y_i$ given the observed sequence, but using our elimination trick, we can get similar computational advantages as seen in the chain example. 


<d-math block>
\begin{aligned}
P(y_i | x_1, \dots, x_T) &= \sum_{y_{-i}} P(y_1, \dots, y_T, x_1, \dots, x_T) \\
&= \sum_{y_{-i}} P(y_1) P(x_1 | y_1) P(y_2 | y_1) \dots P(y_T | y_{T-1}) P(x_T | y_T) \\  
\end{aligned}
</d-math>


With this model, we have two intuitive choices for the order of variables to eliminate. We could start from the first time step (known as the *Forward Algorithm*) or start from the final time step (known as the *Backward Algorithm*).

Note that to each notation, we will represent a summation over all random variables $y$ except the $i$th variable as $y_{-i}$.

#### Forward Algorithm

If we choose to eliminate variables by starting at the beginning of the chain, we would first group factors as follows:


<d-math block>
\begin{aligned}
P(y_i | x_1, \dots, x_T) &= \sum_{y_{-1, -i}} P(x_2 | y_2) P(y_3 | y_2) \dots P(y_T | y_{T-1}) P(x_T | y_T) \sum_{y_1} P(y_1) P(x_1 | y_1) P(y_2 | y_1)\\  
&=  \sum_{y_{-1, -i}} P(x_2 | y_2) P(y_3 | y_2) \dots P(y_T | y_{T-1}) P(x_T | y_T) \phi(x_1, y_2) \\  
&=  \sum_{y_{-1, -i}} P(x_2 | y_2) P(y_3 | y_2) \dots P(y_T | y_{T-1}) P(x_T | y_T) P(x_1, y_2) \\  
\end{aligned}
</d-math>

We can continue in this pattern with each intermediate term $\phi(\cdot)$ representing a joint probability. 


#### Backward Algorithm

If we choose to eliminate variables by starting at the end of the chain, we would first group factors as follows:


<d-math block>
\begin{aligned}
P(y_i | x_1, \dots, x_T) &= \sum_{y_{-T, -i}} P(y_1) P(x_1 | y_1) P(y_2 | y_1) \dots P(x_{T-1} | y_{T-1}) P(y_{T-1} | y_{T-2}) \sum_{y_T} P(y_T | y_{T-1}) P(x_T | y_T) \\  
&= \sum_{y_{-T, -i}} P(y_1) P(x_1 | y_1) P(y_2 | y_1) \dots P(x_{T-1} | y_{T-1}) P(y_{T-1} | y_{T-2}) \phi(x_T, y_{T-1})
&= \sum_{y_{-T, -i}} P(y_1) P(x_1 | y_1) P(y_2 | y_1) \dots P(x_{T-1} | y_{T-1}) P(y_{T-1} | y_{T-2}) \P(x_T | y_{T-1})  
\end{aligned}
</d-math>

We can continue in this pattern with each intermediate term $\phi(\cdot)$ representing a conditional probability. 

### Takeaways from Examples

The main takeaways from our exploration are that elimination provides a systematic way to efficiently do exact inference and that while we can generally create intermediate factors, the semantics of the intermediate factors can vary. 

## Generalizing Elimination

(Graph elimination here)

## Message Passing Algorithms

Now we have devised a general Eliminate algorithm that is able to works on every graph. However, it is still limited to answering only single-node queries. In this section, we build on the same idea of exploiting local structure of a graph to manipulate factors more efficiently, and formulate a class of exact inference algorithms based on the Clique tree and Factor graph data structures. Doing so will give us important insight on the way inference works in general, and also provide computational benefits in certain situations. [TODO: refactor this overview?]


#### Variable elimination and Clique Trees [cit]

(1 - Koller, first pages up to sum product - connect to Eliminate (basically understanding eliminate part of the slides))

Let us start by drawing a connection between variable elimination process as we have seen in Eliminate algorithm, and a special data structure called a Clique tree (also known by the names of Junction or Join tree). Recall that performing one step of variable elimination involved creating a factor $\psi_i$ by multiplying several existing factors, and then one variable is summed out of $\psi_i$ to create a factor $\tau_i$ that is sent to other factors as a "message". A run of this algorithm defines a *Clique tree*: it is an undirected graph with nodes corresponding to factors $\psi_i$, or cliques of variables $C_i$ in its scope; an edge between $C_i$ and $C_j$ is added if a message $\tau_i$ is used to in the computation of $C_j$'s message $\tau_j$. As [TODO], this graph can be seen to be a tree. Figure [FIG] presents an example [TODO: maybe add Fig 10.1 on p.346 of Koller, and the corresponding VE run].

Moreover, there is a simple characterization of exactly those trees with $C_i \subseteq X$ as nodes and $S_{i,j} \subseteq C_i\cap C_j$ as edges that are clique trees defined by some variable elimination procedure. This lets us identify clique trees with executions of variable elimination. As we will see, interpreting variable elimination in terms of clique trees has several computational advantages. For example, one tree may be used as a basis for executing several different elimination orderings. Furthermore, it makes it possible to cache intermediate messages for answering multiple marginal probability queries more efficiently.


#### Sum-Product Message Passing: Junction Tree algorithm [cit]

(2 - sum product (belief propagation) message passing: look into Jordan; only works for trees/polytrees?; also perhaps mention a closely related algorithm for finding MAP estimates (Max-product); when BP is ran on a non-tree graph, this is Loopy BP and should be run iteratively)

The Sum-Product algorithm provides a way to use a Clique tree to guide variable elimination. Starting with a clique tree $\Tau$, we perform the following steps: [TODO: 1) choose root to be a clique that contains vars of interest, 2) orient the graph upward, 3) initialize by multiplying factors assigned to each clique $C_i$, 4) pass messages bottom-up]

On running several queries more efficiently: TODO [10.2.2 clique tree calibration]

The resulting Junction tree algorithm is a general algorithm for exact inference. However, its applicability relies on construction of a Junction tree, which is an NP-hard problem and thus may be computationally demanding. Next, we will present a more specialized instantiation of the Sum-product algorithm that is limited to trees or tree-like structures, but is more efficient. Moreover, it can be applied to non-trees in an iterative fashion, resulting in an approximate inference algorithm known as *Loopy Belief propagation*.


#### Sum-Product Message Passing through Factor graphs [cit]

(3 - Constructing junction tree is computationally exp (NP-hard); for trees/polytrees)

[Chapter 4 of Jordan]


#### Some obscure stuff I will take care of at the last moment

(4 - Minka?)

